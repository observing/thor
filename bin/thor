#!/usr/bin/env node
'use strict';

var Metrics = require('../metrics')
  , colors = require('colors')
  , async = require('async')
  , path = require('path')
  , os = require('os');

function collect(val, memo) {
  if(!memo){
    memo = [];
  }
  memo.push(val);
  return memo;
}

function parseInteger(val){
  if(val){
    return parseInt(val);
  }
}

//
// Setup the Command-Line Interface.
//
var cli = require('commander');

cli.usage('[options] ws://localhost')
   .option('-A, --amount <connections>', 'the amount of persistent connections to generate', parseInteger, 10000)
   .option('-C, --concurrent <connections>', 'how many concurrent-connections per second', parseInteger, 0)
   .option('-M, --messages <messages>', 'messages to be send per connection', parseInteger, 1)
   .option('-H, --header [header]', 'a header to pass to each connection', collect, [])
   .option('-P, --protocol <protocol>', 'WebSocket protocol version', parseInteger, 13)
   .option('-B, --buffer <size>', 'size of the messages that are send', parseInteger, 1024)
   .option('-W, --workers <cpus>', 'workers to be spawned', parseInteger, os.cpus().length)
   .option('-G, --generator <file>', 'custom message generators')
   .option('-M, --masked', 'send the messaged with a mask')
   .option('-b, --binary', 'send binary messages instead of utf-8')
   .version(require('../package.json').version)
   .parse(process.argv);

//
// Check if all required arguments are supplied, if we don't have a valid url we
// should bail out
//
if (!cli.args.length) return [
    'Thor:'
  , 'Odin is disappointed in you... pity human! You forgot to supply the urls.'
].forEach(function stderr(line) {
  console.error(line);
});

//
// By Odin's beard, unleash thunder!
//
var cluster = require('cluster')
  , workers = cli.workers || 1
  , ids = Object.create(null)
  , concurrents = Object.create(null)
  , connections = 0
  , received = 0
  , robin = [];

//
// Process headers
//
var headers = {};
cli.header.forEach(function(header){
  var keyValue = header.split(':');
  var key = keyValue[0];
  var value = keyValue[1];
  if(!key || !value){
    console.warn('Header \'' +  + '\' is wrongly defined. A header should looks like \'key:value\'.');
    return;
  }
  headers[key.trim()] = value.trim();
});

cluster.setupMaster({
    exec: path.resolve(__dirname, '../mjolnir.js')
  , silent: false
  , args: [
      cli.generator
      ? path.resolve(process.cwd(), cli.generator)
      : path.resolve(__dirname, '../generator.js'),
      cli.protocol,
      !!cli.masked,
      !!cli.binary,
      JSON.stringify(headers)
    ]
});

while (workers--) cluster.fork();

Object.keys(cluster.workers).forEach(function each(id) {
  var worker = cluster.workers[id];

  worker.on('message', function message(data) {
    if ('concurrent' in data) concurrents[data.id] = data.concurrent;

    switch (data.type) {
      case 'open':
        metrics.handshaken(data);
        worker.emit('open::'+ data.id);

        // Output the connection progress
        ++connections;
        break;

      case 'close':
        delete ids[data.id];

        metrics.close(data);
        break;

      case 'error':
        delete ids[data.id];

        metrics.error(data);
        break;

      case 'message':
        received++;
        metrics.message(data);
    }

    //
    // Check if we have processed all connections so we can quit cleanly.
    //
    if (!Object.keys(ids).length) process.exit();
  });

  // Add our worker to our round robin queue so we can balance all our requests
  // across the different workers that we spawned.
  robin.push(worker);
});

//
// Output live, real-time stats.
//
function live() {
  var frames = live.frames
    , len = frames.length
    , interval = 100
    , i = 0;

  live.interval = setInterval(function tick() {
    var active = Object.keys(concurrents).reduce(function (count, id) {
      return count + (concurrents[id] || 0);
    }, 0);

    process.stdout.write('\r'+ frames[i++ % len] +' Progress :: '.white + [
      'Created '.white + connections.toString().green,
      'Active '.white + active.toString().green
    ].join(', '));
  }, interval);
}

/**
 * Live frames.
 *
 * @type {Array}
 * @api private
 */
live.frames = [
    '  \u001b[96m◜ \u001b[90m'
  , '  \u001b[96m◠ \u001b[90m'
  , '  \u001b[96m◝ \u001b[90m'
  , '  \u001b[96m◞ \u001b[90m'
  , '  \u001b[96m◡ \u001b[90m'
  , '  \u001b[96m◟ \u001b[90m'
];

/**
 * Stop the live stats from running.
 *
 * @api private
 */
live.stop = function stop() {
  process.stdout.write('\u001b[2K');
  clearInterval(live.interval);
};

//
// Up our WebSocket socket connections.
//
[
    ''
  , 'Thor:                                                  version: '+ cli._version
  , ''
  , 'God of Thunder, son of Odin and smasher of WebSockets!'
  , ''
  , 'Thou shall:'
  , '- Spawn '+ cli.workers +' workers.'
  , '- Create '+ (cli.concurrent || 'all the') + ' concurrent/parallel connections.'
  , '- Smash '+ (cli.amount || 'infinite') +' connections with the mighty Mjölnir.'
  , ''
  , 'The answers you seek shall be yours, once I claim what is mine.'
  , ''
].forEach(function stdout(line) {
  console.log(line);
});

//
// Metrics collection.
//
var metrics = new Metrics(cli.amount * cli.args.length);

// Iterate over all the urls so we can target multiple locations at once, which
// is helpfull if you are testing multiple loadbalancer endpoints for example.
async.forEach(cli.args, function forEach(url, done) {
  var i = cli.amount
    , completed = 0;

  console.log('Connecting to %s', url);

  //
  // Create a simple WebSocket connection generator.
  //
  var queue = async.queue(function working(id, fn) {
    var worker = robin.shift();

    // Register the id, so we can keep track of the connections that we still
    // need to process.
    ids[id] = 1;

    // Process the connections
    worker.send({ url: url, size: cli.buffer, messages: cli.messages, id: id });
    worker.once('open::'+ id, fn);

    // Add the worker back at the end of the round robin queue.
    robin.push(worker);
  }, cli.concurrent || Infinity);

  // When all the events are processed successfully we should call.. back ;P
  queue.drain = done;

  // Add all connections to the processing queue;
  while (i--) queue.push(url +'::'+ i);
}, function established(err) {
  metrics.established();
});

//
// We are setup, everything is running
//
console.log('');
live();

process.once('SIGINT', function end() {
  robin.forEach(function nuke(worker) {
    try { worker.send({ shutdown: true }); }
    catch (e) {}
  });
});

process.once('exit', function summary() {
  live.stop();
  metrics.established().stop().summary();
});
